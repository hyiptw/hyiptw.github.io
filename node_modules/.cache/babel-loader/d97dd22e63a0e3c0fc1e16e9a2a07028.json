{"ast":null,"code":"import _regeneratorRuntime from \"/home/fs/srmswap/oyster-swap/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/fs/srmswap/oyster-swap/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _toConsumableArray from \"/home/fs/srmswap/oyster-swap/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/fs/srmswap/oyster-swap/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/fs/srmswap/oyster-swap/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/home/fs/srmswap/oyster-swap/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/home/fs/srmswap/oyster-swap/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/fs/srmswap/oyster-swap/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/fs/srmswap/oyster-swap/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport assert from 'assert';\nimport BN from 'bn.js';\nimport { blob, struct, u32, u8 } from 'buffer-layout';\nimport { sendAndConfirmTransaction as sendAndConfirmTransaction$1, PublicKey, Account, Transaction, SystemProgram, TransactionInstruction, SYSVAR_RENT_PUBKEY } from '@solana/web3.js';\n/**\n * Layout for a public key\n */\n\nvar publicKey = function publicKey() {\n  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'publicKey';\n  return blob(32, property);\n};\n/**\n * Layout for a 64bit unsigned value\n */\n\n\nvar uint64 = function uint64() {\n  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'uint64';\n  return blob(8, property);\n};\n\nfunction sendAndConfirmTransaction(title, connection, transaction) {\n  for (var _len = arguments.length, signers = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    signers[_key - 3] = arguments[_key];\n  }\n\n  return sendAndConfirmTransaction$1(connection, transaction, signers, {\n    skipPreflight: false,\n    commitment: 'recent',\n    preflightCommitment: 'recent'\n  });\n}\n/**\n * 64-bit value\n */\n\n\nvar u64 = /*#__PURE__*/function (_BN) {\n  _inherits(u64, _BN);\n\n  var _super = _createSuper(u64);\n\n  function u64() {\n    _classCallCheck(this, u64);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(u64, [{\n    key: \"toBuffer\",\n\n    /**\n     * Convert to Buffer representation\n     */\n    value: function toBuffer() {\n      var a = _get(_getPrototypeOf(u64.prototype), \"toArray\", this).call(this).reverse();\n\n      var b = Buffer.from(a);\n\n      if (b.length === 8) {\n        return b;\n      }\n\n      assert(b.length < 8, 'u64 too large');\n      var zeroPad = Buffer.alloc(8);\n      b.copy(zeroPad);\n      return zeroPad;\n    }\n    /**\n     * Construct a u64 from Buffer representation\n     */\n\n  }], [{\n    key: \"fromBuffer\",\n    value: function fromBuffer(buffer) {\n      assert(buffer.length === 8, \"Invalid buffer length: \".concat(buffer.length));\n      return new BN(_toConsumableArray(buffer).reverse().map(function (i) {\n        return \"00\".concat(i.toString(16)).slice(-2);\n      }).join(''), 16);\n    }\n  }]);\n\n  return u64;\n}(BN);\n\nfunction isAccount(accountOrPublicKey) {\n  return 'publicKey' in accountOrPublicKey;\n}\n\nvar AuthorityTypeCodes = {\n  MintTokens: 0,\n  FreezeAccount: 1,\n  AccountOwner: 2,\n  CloseAccount: 3\n}; // The address of the special mint for wrapped native token.\n\nvar NATIVE_MINT = new PublicKey('So11111111111111111111111111111111111111112');\n/**\n * Information about the mint\n */\n\nvar MintLayout = struct([u32('mintAuthorityOption'), publicKey('mintAuthority'), uint64('supply'), u8('decimals'), u8('isInitialized'), u32('freezeAuthorityOption'), publicKey('freezeAuthority')]);\n/**\n * Information about an account\n */\n\n/**\n * @private\n */\n\nvar AccountLayout = struct([publicKey('mint'), publicKey('owner'), uint64('amount'), u32('delegateOption'), publicKey('delegate'), u8('state'), u32('isNativeOption'), uint64('isNative'), uint64('delegatedAmount'), u32('closeAuthorityOption'), publicKey('closeAuthority')]);\n/**\n * Information about an multisig\n */\n\n/**\n * @private\n */\n\nvar MultisigLayout = struct([u8('m'), u8('n'), u8('is_initialized'), publicKey('signer1'), publicKey('signer2'), publicKey('signer3'), publicKey('signer4'), publicKey('signer5'), publicKey('signer6'), publicKey('signer7'), publicKey('signer8'), publicKey('signer9'), publicKey('signer10'), publicKey('signer11')]);\n/**\n * An ERC20-like Token\n */\n\nvar Token = /*#__PURE__*/function () {\n  /**\n   * @private\n   */\n\n  /**\n   * The public key identifying this mint\n   */\n\n  /**\n   * Program Identifier for the Token program\n   */\n\n  /**\n   * Fee payer\n   */\n\n  /**\n   * Create a Token object attached to the specific mint\n   *\n   * @param connection The connection to use\n   * @param token Public key of the mint\n   * @param programId token programId\n   * @param payer Payer of fees\n   */\n  function Token(connection, publicKey, programId, payer) {\n    _classCallCheck(this, Token);\n\n    _defineProperty(this, \"connection\", void 0);\n\n    _defineProperty(this, \"publicKey\", void 0);\n\n    _defineProperty(this, \"programId\", void 0);\n\n    _defineProperty(this, \"payer\", void 0);\n\n    Object.assign(this, {\n      connection: connection,\n      publicKey: publicKey,\n      programId: programId,\n      payer: payer\n    });\n  }\n  /**\n   * Get the minimum balance for the mint to be rent exempt\n   *\n   * @return Number of lamports required\n   */\n\n\n  _createClass(Token, [{\n    key: \"createAccount\",\n\n    /**\n     * Create and initialize a new account.\n     *\n     * This account may then be used as a `transfer()` or `approve()` destination\n     *\n     * @param owner User account that will own the new account\n     * @return Public key of the new empty account\n     */\n    value: function () {\n      var _createAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(owner) {\n        var balanceNeeded, newAccount, transaction, mintPublicKey;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return Token.getMinBalanceRentForExemptAccount(this.connection);\n\n              case 2:\n                balanceNeeded = _context.sent;\n                newAccount = new Account();\n                transaction = new Transaction();\n                transaction.add(SystemProgram.createAccount({\n                  fromPubkey: this.payer.publicKey,\n                  newAccountPubkey: newAccount.publicKey,\n                  lamports: balanceNeeded,\n                  space: AccountLayout.span,\n                  programId: this.programId\n                }));\n                mintPublicKey = this.publicKey;\n                transaction.add(Token.createInitAccountInstruction(this.programId, mintPublicKey, newAccount.publicKey, owner)); // Send the two instructions\n\n                _context.next = 10;\n                return sendAndConfirmTransaction('createAccount and InitializeAccount', this.connection, transaction, this.payer, newAccount);\n\n              case 10:\n                return _context.abrupt(\"return\", newAccount.publicKey);\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function createAccount(_x) {\n        return _createAccount.apply(this, arguments);\n      }\n\n      return createAccount;\n    }()\n    /**\n     * Create and initialize a new account on the special native token mint.\n     *\n     * In order to be wrapped, the account must have a balance of native tokens\n     * when it is initialized with the token program.\n     *\n     * This function sends lamports to the new account before initializing it.\n     *\n     * @param connection A solana web3 connection\n     * @param programId The token program ID\n     * @param owner The owner of the new token account\n     * @param payer The source of the lamports to initialize, and payer of the initialization fees.\n     * @param amount The amount of lamports to wrap\n     * @return {Promise<PublicKey>} The new token account\n     */\n\n  }, {\n    key: \"createMultisig\",\n\n    /**\n     * Create and initialize a new multisig.\n     *\n     * This account may then be used for multisignature verification\n     *\n     * @param m Number of required signatures\n     * @param signers Full set of signers\n     * @return Public key of the new multisig account\n     */\n    value: function () {\n      var _createMultisig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(m, signers) {\n        var multisigAccount, balanceNeeded, transaction, keys, dataLayout, data;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                multisigAccount = new Account(); // Allocate memory for the account\n\n                _context2.next = 3;\n                return Token.getMinBalanceRentForExemptMultisig(this.connection);\n\n              case 3:\n                balanceNeeded = _context2.sent;\n                transaction = new Transaction();\n                transaction.add(SystemProgram.createAccount({\n                  fromPubkey: this.payer.publicKey,\n                  newAccountPubkey: multisigAccount.publicKey,\n                  lamports: balanceNeeded,\n                  space: MultisigLayout.span,\n                  programId: this.programId\n                })); // create the new account\n\n                keys = [{\n                  pubkey: multisigAccount.publicKey,\n                  isSigner: false,\n                  isWritable: true\n                }, {\n                  pubkey: SYSVAR_RENT_PUBKEY,\n                  isSigner: false,\n                  isWritable: false\n                }];\n                signers.forEach(function (signer) {\n                  return keys.push({\n                    pubkey: signer,\n                    isSigner: false,\n                    isWritable: false\n                  });\n                });\n                dataLayout = struct([u8('instruction'), u8('m')]);\n                data = Buffer.alloc(dataLayout.span);\n                dataLayout.encode({\n                  instruction: 2,\n                  // InitializeMultisig instruction\n                  m: m\n                }, data);\n                transaction.add({\n                  keys: keys,\n                  programId: this.programId,\n                  data: data\n                }); // Send the two instructions\n\n                _context2.next = 14;\n                return sendAndConfirmTransaction('createAccount and InitializeMultisig', this.connection, transaction, this.payer, multisigAccount);\n\n              case 14:\n                return _context2.abrupt(\"return\", multisigAccount.publicKey);\n\n              case 15:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function createMultisig(_x2, _x3) {\n        return _createMultisig.apply(this, arguments);\n      }\n\n      return createMultisig;\n    }()\n    /**\n     * Retrieve mint information\n     */\n\n  }, {\n    key: \"getMintInfo\",\n    value: function () {\n      var _getMintInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var info, data, mintInfo;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.connection.getAccountInfo(this.publicKey);\n\n              case 2:\n                info = _context3.sent;\n\n                if (!(info === null)) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                throw new Error('Failed to find mint account');\n\n              case 5:\n                if (info.owner.equals(this.programId)) {\n                  _context3.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Invalid mint owner: \".concat(JSON.stringify(info.owner)));\n\n              case 7:\n                if (!(info.data.length != MintLayout.span)) {\n                  _context3.next = 9;\n                  break;\n                }\n\n                throw new Error(\"Invalid mint size\");\n\n              case 9:\n                data = Buffer.from(info.data);\n                mintInfo = MintLayout.decode(data);\n\n                if (mintInfo.mintAuthorityOption === 0) {\n                  mintInfo.mintAuthority = null;\n                } else {\n                  mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);\n                }\n\n                mintInfo.supply = u64.fromBuffer(mintInfo.supply);\n                mintInfo.isInitialized = mintInfo.isInitialized != 0;\n\n                if (mintInfo.freezeAuthorityOption === 0) {\n                  mintInfo.freezeAuthority = null;\n                } else {\n                  mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);\n                }\n\n                return _context3.abrupt(\"return\", mintInfo);\n\n              case 16:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getMintInfo() {\n        return _getMintInfo.apply(this, arguments);\n      }\n\n      return getMintInfo;\n    }()\n    /**\n     * Retrieve account information\n     *\n     * @param account Public key of the account\n     */\n\n  }, {\n    key: \"getAccountInfo\",\n    value: function () {\n      var _getAccountInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(account, commitment) {\n        var info, data, accountInfo;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.connection.getAccountInfo(account, commitment);\n\n              case 2:\n                info = _context4.sent;\n\n                if (!(info === null)) {\n                  _context4.next = 5;\n                  break;\n                }\n\n                throw new Error('Failed to find account');\n\n              case 5:\n                if (info.owner.equals(this.programId)) {\n                  _context4.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Invalid account owner\");\n\n              case 7:\n                if (!(info.data.length != AccountLayout.span)) {\n                  _context4.next = 9;\n                  break;\n                }\n\n                throw new Error(\"Invalid account size\");\n\n              case 9:\n                data = Buffer.from(info.data);\n                accountInfo = AccountLayout.decode(data);\n                accountInfo.mint = new PublicKey(accountInfo.mint);\n                accountInfo.owner = new PublicKey(accountInfo.owner);\n                accountInfo.amount = u64.fromBuffer(accountInfo.amount);\n\n                if (accountInfo.delegateOption === 0) {\n                  accountInfo.delegate = null;\n                  accountInfo.delegatedAmount = new u64();\n                } else {\n                  accountInfo.delegate = new PublicKey(accountInfo.delegate);\n                  accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\n                }\n\n                accountInfo.isInitialized = accountInfo.state !== 0;\n                accountInfo.isFrozen = accountInfo.state === 2;\n\n                if (accountInfo.isNativeOption === 1) {\n                  accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\n                  accountInfo.isNative = true;\n                } else {\n                  accountInfo.rentExemptReserve = null;\n                  accountInfo.isNative = false;\n                }\n\n                if (accountInfo.closeAuthorityOption === 0) {\n                  accountInfo.closeAuthority = null;\n                } else {\n                  accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);\n                }\n\n                if (accountInfo.mint.equals(this.publicKey)) {\n                  _context4.next = 21;\n                  break;\n                }\n\n                throw new Error(\"Invalid account mint: \".concat(JSON.stringify(accountInfo.mint), \" !== \").concat(JSON.stringify(this.publicKey)));\n\n              case 21:\n                return _context4.abrupt(\"return\", accountInfo);\n\n              case 22:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getAccountInfo(_x4, _x5) {\n        return _getAccountInfo.apply(this, arguments);\n      }\n\n      return getAccountInfo;\n    }()\n    /**\n     * Retrieve Multisig information\n     *\n     * @param multisig Public key of the account\n     */\n\n  }, {\n    key: \"getMultisigInfo\",\n    value: function () {\n      var _getMultisigInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(multisig) {\n        var info, data, multisigInfo;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.connection.getAccountInfo(multisig);\n\n              case 2:\n                info = _context5.sent;\n\n                if (!(info === null)) {\n                  _context5.next = 5;\n                  break;\n                }\n\n                throw new Error('Failed to find multisig');\n\n              case 5:\n                if (info.owner.equals(this.programId)) {\n                  _context5.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Invalid multisig owner\");\n\n              case 7:\n                if (!(info.data.length != MultisigLayout.span)) {\n                  _context5.next = 9;\n                  break;\n                }\n\n                throw new Error(\"Invalid multisig size\");\n\n              case 9:\n                data = Buffer.from(info.data);\n                multisigInfo = MultisigLayout.decode(data);\n                multisigInfo.signer1 = new PublicKey(multisigInfo.signer1);\n                multisigInfo.signer2 = new PublicKey(multisigInfo.signer2);\n                multisigInfo.signer3 = new PublicKey(multisigInfo.signer3);\n                multisigInfo.signer4 = new PublicKey(multisigInfo.signer4);\n                multisigInfo.signer5 = new PublicKey(multisigInfo.signer5);\n                multisigInfo.signer6 = new PublicKey(multisigInfo.signer6);\n                multisigInfo.signer7 = new PublicKey(multisigInfo.signer7);\n                multisigInfo.signer8 = new PublicKey(multisigInfo.signer8);\n                multisigInfo.signer9 = new PublicKey(multisigInfo.signer9);\n                multisigInfo.signer10 = new PublicKey(multisigInfo.signer10);\n                multisigInfo.signer11 = new PublicKey(multisigInfo.signer11);\n                return _context5.abrupt(\"return\", multisigInfo);\n\n              case 23:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getMultisigInfo(_x6) {\n        return _getMultisigInfo.apply(this, arguments);\n      }\n\n      return getMultisigInfo;\n    }()\n    /**\n     * Transfer tokens to another account\n     *\n     * @param source Source account\n     * @param destination Destination account\n     * @param owner Owner of the source account\n     * @param multiSigners Signing accounts if `owner` is a multiSig\n     * @param amount Number of tokens to transfer\n     */\n\n  }, {\n    key: \"transfer\",\n    value: function () {\n      var _transfer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(source, destination, owner, multiSigners, amount) {\n        var ownerPublicKey, signers;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (isAccount(owner)) {\n                  ownerPublicKey = owner.publicKey;\n                  signers = [owner];\n                } else {\n                  ownerPublicKey = owner;\n                  signers = multiSigners;\n                }\n\n                _context6.next = 3;\n                return sendAndConfirmTransaction.apply(void 0, ['Transfer', this.connection, new Transaction().add(Token.createTransferInstruction(this.programId, source, destination, ownerPublicKey, multiSigners, amount)), this.payer].concat(_toConsumableArray(signers)));\n\n              case 3:\n                return _context6.abrupt(\"return\", _context6.sent);\n\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function transfer(_x7, _x8, _x9, _x10, _x11) {\n        return _transfer.apply(this, arguments);\n      }\n\n      return transfer;\n    }()\n    /**\n     * Grant a third-party permission to transfer up the specified number of tokens from an account\n     *\n     * @param account Public key of the account\n     * @param delegate Account authorized to perform a transfer tokens from the source account\n     * @param owner Owner of the source account\n     * @param multiSigners Signing accounts if `owner` is a multiSig\n     * @param amount Maximum number of tokens the delegate may transfer\n     */\n\n  }, {\n    key: \"approve\",\n    value: function () {\n      var _approve = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(account, delegate, owner, multiSigners, amount) {\n        var ownerPublicKey, signers;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (isAccount(owner)) {\n                  ownerPublicKey = owner.publicKey;\n                  signers = [owner];\n                } else {\n                  ownerPublicKey = owner;\n                  signers = multiSigners;\n                }\n\n                _context7.next = 3;\n                return sendAndConfirmTransaction.apply(void 0, ['Approve', this.connection, new Transaction().add(Token.createApproveInstruction(this.programId, account, delegate, ownerPublicKey, multiSigners, amount)), this.payer].concat(_toConsumableArray(signers)));\n\n              case 3:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function approve(_x12, _x13, _x14, _x15, _x16) {\n        return _approve.apply(this, arguments);\n      }\n\n      return approve;\n    }()\n    /**\n     * Remove approval for the transfer of any remaining tokens\n     *\n     * @param account Public key of the account\n     * @param owner Owner of the source account\n     * @param multiSigners Signing accounts if `owner` is a multiSig\n     */\n\n  }, {\n    key: \"revoke\",\n    value: function () {\n      var _revoke = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(account, owner, multiSigners) {\n        var ownerPublicKey, signers;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (isAccount(owner)) {\n                  ownerPublicKey = owner.publicKey;\n                  signers = [owner];\n                } else {\n                  ownerPublicKey = owner;\n                  signers = multiSigners;\n                }\n\n                _context8.next = 3;\n                return sendAndConfirmTransaction.apply(void 0, ['Revoke', this.connection, new Transaction().add(Token.createRevokeInstruction(this.programId, account, ownerPublicKey, multiSigners)), this.payer].concat(_toConsumableArray(signers)));\n\n              case 3:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function revoke(_x17, _x18, _x19) {\n        return _revoke.apply(this, arguments);\n      }\n\n      return revoke;\n    }()\n    /**\n     * Assign a new authority to the account\n     *\n     * @param account Public key of the account\n     * @param newAuthority New authority of the account\n     * @param authorityType Type of authority to set\n     * @param currentAuthority Current authority of the account\n     * @param multiSigners Signing accounts if `currentAuthority` is a multiSig\n     */\n\n  }, {\n    key: \"setAuthority\",\n    value: function () {\n      var _setAuthority = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(account, newAuthority, authorityType, currentAuthority, multiSigners) {\n        var currentAuthorityPublicKey, signers;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (isAccount(currentAuthority)) {\n                  currentAuthorityPublicKey = currentAuthority.publicKey;\n                  signers = [currentAuthority];\n                } else {\n                  currentAuthorityPublicKey = currentAuthority;\n                  signers = multiSigners;\n                }\n\n                _context9.next = 3;\n                return sendAndConfirmTransaction.apply(void 0, ['SetAuthority', this.connection, new Transaction().add(Token.createSetAuthorityInstruction(this.programId, account, newAuthority, authorityType, currentAuthorityPublicKey, multiSigners)), this.payer].concat(_toConsumableArray(signers)));\n\n              case 3:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function setAuthority(_x20, _x21, _x22, _x23, _x24) {\n        return _setAuthority.apply(this, arguments);\n      }\n\n      return setAuthority;\n    }()\n    /**\n     * Mint new tokens\n     *\n     * @param dest Public key of the account to mint to\n     * @param authority Minting authority\n     * @param multiSigners Signing accounts if `authority` is a multiSig\n     * @param amount Amount to mint\n     */\n\n  }, {\n    key: \"mintTo\",\n    value: function () {\n      var _mintTo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(dest, authority, multiSigners, amount) {\n        var ownerPublicKey, signers;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (isAccount(authority)) {\n                  ownerPublicKey = authority.publicKey;\n                  signers = [authority];\n                } else {\n                  ownerPublicKey = authority;\n                  signers = multiSigners;\n                }\n\n                _context10.next = 3;\n                return sendAndConfirmTransaction.apply(void 0, ['MintTo', this.connection, new Transaction().add(Token.createMintToInstruction(this.programId, this.publicKey, dest, ownerPublicKey, multiSigners, amount)), this.payer].concat(_toConsumableArray(signers)));\n\n              case 3:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function mintTo(_x25, _x26, _x27, _x28) {\n        return _mintTo.apply(this, arguments);\n      }\n\n      return mintTo;\n    }()\n    /**\n     * Burn tokens\n     *\n     * @param account Account to burn tokens from\n     * @param owner Account owner\n     * @param multiSigners Signing accounts if `owner` is a multiSig\n     * @param amount Amount to burn\n     */\n\n  }, {\n    key: \"burn\",\n    value: function () {\n      var _burn = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(account, owner, multiSigners, amount) {\n        var ownerPublicKey, signers;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                if (isAccount(owner)) {\n                  ownerPublicKey = owner.publicKey;\n                  signers = [owner];\n                } else {\n                  ownerPublicKey = owner;\n                  signers = multiSigners;\n                }\n\n                _context11.next = 3;\n                return sendAndConfirmTransaction.apply(void 0, ['Burn', this.connection, new Transaction().add(Token.createBurnInstruction(this.programId, this.publicKey, account, ownerPublicKey, multiSigners, amount)), this.payer].concat(_toConsumableArray(signers)));\n\n              case 3:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function burn(_x29, _x30, _x31, _x32) {\n        return _burn.apply(this, arguments);\n      }\n\n      return burn;\n    }()\n    /**\n     * Close account\n     *\n     * @param account Account to close\n     * @param dest Account to receive the remaining balance of the closed account\n     * @param authority Authority which is allowed to close the account\n     * @param multiSigners Signing accounts if `authority` is a multiSig\n     */\n\n  }, {\n    key: \"closeAccount\",\n    value: function () {\n      var _closeAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(account, dest, authority, multiSigners) {\n        var authorityPublicKey, signers;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                if (isAccount(authority)) {\n                  authorityPublicKey = authority.publicKey;\n                  signers = [authority];\n                } else {\n                  authorityPublicKey = authority;\n                  signers = multiSigners;\n                }\n\n                _context12.next = 3;\n                return sendAndConfirmTransaction.apply(void 0, ['CloseAccount', this.connection, new Transaction().add(Token.createCloseAccountInstruction(this.programId, account, dest, authorityPublicKey, multiSigners)), this.payer].concat(_toConsumableArray(signers)));\n\n              case 3:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function closeAccount(_x33, _x34, _x35, _x36) {\n        return _closeAccount.apply(this, arguments);\n      }\n\n      return closeAccount;\n    }()\n    /**\n     * Freeze account\n     *\n     * @param account Account to freeze\n     * @param authority The mint freeze authority\n     * @param multiSigners Signing accounts if `authority` is a multiSig\n     */\n\n  }, {\n    key: \"freezeAccount\",\n    value: function () {\n      var _freezeAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(account, authority, multiSigners) {\n        var authorityPublicKey, signers;\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                if (isAccount(authority)) {\n                  authorityPublicKey = authority.publicKey;\n                  signers = [authority];\n                } else {\n                  authorityPublicKey = authority;\n                  signers = multiSigners;\n                }\n\n                _context13.next = 3;\n                return sendAndConfirmTransaction.apply(void 0, ['FreezeAccount', this.connection, new Transaction().add(Token.createFreezeAccountInstruction(this.programId, account, this.publicKey, authorityPublicKey, multiSigners)), this.payer].concat(_toConsumableArray(signers)));\n\n              case 3:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function freezeAccount(_x37, _x38, _x39) {\n        return _freezeAccount.apply(this, arguments);\n      }\n\n      return freezeAccount;\n    }()\n    /**\n     * Thaw account\n     *\n     * @param account Account to thaw\n     * @param authority The mint freeze authority\n     * @param multiSigners Signing accounts if `authority` is a multiSig\n     */\n\n  }, {\n    key: \"thawAccount\",\n    value: function () {\n      var _thawAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(account, authority, multiSigners) {\n        var authorityPublicKey, signers;\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                if (isAccount(authority)) {\n                  authorityPublicKey = authority.publicKey;\n                  signers = [authority];\n                } else {\n                  authorityPublicKey = authority;\n                  signers = multiSigners;\n                }\n\n                _context14.next = 3;\n                return sendAndConfirmTransaction.apply(void 0, ['ThawAccount', this.connection, new Transaction().add(Token.createThawAccountInstruction(this.programId, account, this.publicKey, authorityPublicKey, multiSigners)), this.payer].concat(_toConsumableArray(signers)));\n\n              case 3:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function thawAccount(_x40, _x41, _x42) {\n        return _thawAccount.apply(this, arguments);\n      }\n\n      return thawAccount;\n    }()\n    /**\n     * Transfer tokens to another account, asserting the token mint and decimals\n     *\n     * @param source Source account\n     * @param destination Destination account\n     * @param owner Owner of the source account\n     * @param multiSigners Signing accounts if `owner` is a multiSig\n     * @param amount Number of tokens to transfer\n     * @param decimals Number of decimals in transfer amount\n     */\n\n  }, {\n    key: \"transfer2\",\n    value: function () {\n      var _transfer2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(source, destination, owner, multiSigners, amount, decimals) {\n        var ownerPublicKey, signers;\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                if (isAccount(owner)) {\n                  ownerPublicKey = owner.publicKey;\n                  signers = [owner];\n                } else {\n                  ownerPublicKey = owner;\n                  signers = multiSigners;\n                }\n\n                _context15.next = 3;\n                return sendAndConfirmTransaction.apply(void 0, ['Transfer2', this.connection, new Transaction().add(Token.createTransfer2Instruction(this.programId, source, this.publicKey, destination, ownerPublicKey, multiSigners, amount, decimals)), this.payer].concat(_toConsumableArray(signers)));\n\n              case 3:\n                return _context15.abrupt(\"return\", _context15.sent);\n\n              case 4:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function transfer2(_x43, _x44, _x45, _x46, _x47, _x48) {\n        return _transfer2.apply(this, arguments);\n      }\n\n      return transfer2;\n    }()\n    /**\n     * Grant a third-party permission to transfer up the specified number of tokens from an account,\n     * asserting the token mint and decimals\n     *\n     * @param account Public key of the account\n     * @param delegate Account authorized to perform a transfer tokens from the source account\n     * @param owner Owner of the source account\n     * @param multiSigners Signing accounts if `owner` is a multiSig\n     * @param amount Maximum number of tokens the delegate may transfer\n     * @param decimals Number of decimals in approve amount\n     */\n\n  }, {\n    key: \"approve2\",\n    value: function () {\n      var _approve2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16(account, delegate, owner, multiSigners, amount, decimals) {\n        var ownerPublicKey, signers;\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                if (isAccount(owner)) {\n                  ownerPublicKey = owner.publicKey;\n                  signers = [owner];\n                } else {\n                  ownerPublicKey = owner;\n                  signers = multiSigners;\n                }\n\n                _context16.next = 3;\n                return sendAndConfirmTransaction.apply(void 0, ['Approve2', this.connection, new Transaction().add(Token.createApprove2Instruction(this.programId, account, this.publicKey, delegate, ownerPublicKey, multiSigners, amount, decimals)), this.payer].concat(_toConsumableArray(signers)));\n\n              case 3:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function approve2(_x49, _x50, _x51, _x52, _x53, _x54) {\n        return _approve2.apply(this, arguments);\n      }\n\n      return approve2;\n    }()\n    /**\n     * Mint new tokens, asserting the token mint and decimals\n     *\n     * @param dest Public key of the account to mint to\n     * @param authority Minting authority\n     * @param multiSigners Signing accounts if `authority` is a multiSig\n     * @param amount Amount to mint\n     * @param decimals Number of decimals in amount to mint\n     */\n\n  }, {\n    key: \"mintTo2\",\n    value: function () {\n      var _mintTo2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17(dest, authority, multiSigners, amount, decimals) {\n        var ownerPublicKey, signers;\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                if (isAccount(authority)) {\n                  ownerPublicKey = authority.publicKey;\n                  signers = [authority];\n                } else {\n                  ownerPublicKey = authority;\n                  signers = multiSigners;\n                }\n\n                _context17.next = 3;\n                return sendAndConfirmTransaction.apply(void 0, ['MintTo2', this.connection, new Transaction().add(Token.createMintTo2Instruction(this.programId, this.publicKey, dest, ownerPublicKey, multiSigners, amount, decimals)), this.payer].concat(_toConsumableArray(signers)));\n\n              case 3:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function mintTo2(_x55, _x56, _x57, _x58, _x59) {\n        return _mintTo2.apply(this, arguments);\n      }\n\n      return mintTo2;\n    }()\n    /**\n     * Burn tokens, asserting the token mint and decimals\n     *\n     * @param account Account to burn tokens from\n     * @param owner Account owner\n     * @param multiSigners Signing accounts if `owner` is a multiSig\n     * @param amount Amount to burn\n     * @param decimals Number of decimals in amount to burn\n     */\n\n  }, {\n    key: \"burn2\",\n    value: function () {\n      var _burn2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18(account, owner, multiSigners, amount, decimals) {\n        var ownerPublicKey, signers;\n        return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                if (isAccount(owner)) {\n                  ownerPublicKey = owner.publicKey;\n                  signers = [owner];\n                } else {\n                  ownerPublicKey = owner;\n                  signers = multiSigners;\n                }\n\n                _context18.next = 3;\n                return sendAndConfirmTransaction.apply(void 0, ['Burn2', this.connection, new Transaction().add(Token.createBurn2Instruction(this.programId, this.publicKey, account, ownerPublicKey, multiSigners, amount, decimals)), this.payer].concat(_toConsumableArray(signers)));\n\n              case 3:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n\n      function burn2(_x60, _x61, _x62, _x63, _x64) {\n        return _burn2.apply(this, arguments);\n      }\n\n      return burn2;\n    }()\n    /**\n     * Construct an InitializeMint instruction\n     *\n     * @param programId SPL Token program account\n     * @param mint Token mint account\n     * @param decimals Number of decimals in token account amounts\n     * @param mintAuthority Minting authority\n     * @param freezeAuthority Optional authority that can freeze token accounts\n     */\n\n  }], [{\n    key: \"getMinBalanceRentForExemptMint\",\n    value: function () {\n      var _getMinBalanceRentForExemptMint = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19(connection) {\n        return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                _context19.next = 2;\n                return connection.getMinimumBalanceForRentExemption(MintLayout.span);\n\n              case 2:\n                return _context19.abrupt(\"return\", _context19.sent);\n\n              case 3:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19);\n      }));\n\n      function getMinBalanceRentForExemptMint(_x65) {\n        return _getMinBalanceRentForExemptMint.apply(this, arguments);\n      }\n\n      return getMinBalanceRentForExemptMint;\n    }()\n    /**\n     * Get the minimum balance for the account to be rent exempt\n     *\n     * @return Number of lamports required\n     */\n\n  }, {\n    key: \"getMinBalanceRentForExemptAccount\",\n    value: function () {\n      var _getMinBalanceRentForExemptAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee20(connection) {\n        return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                _context20.next = 2;\n                return connection.getMinimumBalanceForRentExemption(AccountLayout.span);\n\n              case 2:\n                return _context20.abrupt(\"return\", _context20.sent);\n\n              case 3:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20);\n      }));\n\n      function getMinBalanceRentForExemptAccount(_x66) {\n        return _getMinBalanceRentForExemptAccount.apply(this, arguments);\n      }\n\n      return getMinBalanceRentForExemptAccount;\n    }()\n    /**\n     * Get the minimum balance for the multsig to be rent exempt\n     *\n     * @return Number of lamports required\n     */\n\n  }, {\n    key: \"getMinBalanceRentForExemptMultisig\",\n    value: function () {\n      var _getMinBalanceRentForExemptMultisig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee21(connection) {\n        return _regeneratorRuntime.wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                _context21.next = 2;\n                return connection.getMinimumBalanceForRentExemption(MultisigLayout.span);\n\n              case 2:\n                return _context21.abrupt(\"return\", _context21.sent);\n\n              case 3:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21);\n      }));\n\n      function getMinBalanceRentForExemptMultisig(_x67) {\n        return _getMinBalanceRentForExemptMultisig.apply(this, arguments);\n      }\n\n      return getMinBalanceRentForExemptMultisig;\n    }()\n    /**\n     * Create and initialize a token.\n     *\n     * @param connection The connection to use\n     * @param payer Fee payer for transaction\n     * @param mintAuthority Account or multisig that will control minting\n     * @param freezeAuthority Optional account or multisig that can freeze token accounts\n     * @param decimals Location of the decimal place\n     * @param programId Optional token programId, uses the system programId by default\n     * @return Token object for the newly minted token\n     */\n\n  }, {\n    key: \"createMint\",\n    value: function () {\n      var _createMint = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee22(connection, payer, mintAuthority, freezeAuthority, decimals, programId) {\n        var mintAccount, token, balanceNeeded, transaction;\n        return _regeneratorRuntime.wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                mintAccount = new Account();\n                token = new Token(connection, mintAccount.publicKey, programId, payer); // Allocate memory for the account\n\n                _context22.next = 4;\n                return Token.getMinBalanceRentForExemptMint(connection);\n\n              case 4:\n                balanceNeeded = _context22.sent;\n                transaction = new Transaction();\n                transaction.add(SystemProgram.createAccount({\n                  fromPubkey: payer.publicKey,\n                  newAccountPubkey: mintAccount.publicKey,\n                  lamports: balanceNeeded,\n                  space: MintLayout.span,\n                  programId: programId\n                }));\n                transaction.add(Token.createInitMintInstruction(programId, mintAccount.publicKey, decimals, mintAuthority, freezeAuthority)); // Send the two instructions\n\n                _context22.next = 10;\n                return sendAndConfirmTransaction('createAccount and InitializeMint', connection, transaction, payer, mintAccount);\n\n              case 10:\n                return _context22.abrupt(\"return\", token);\n\n              case 11:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22);\n      }));\n\n      function createMint(_x68, _x69, _x70, _x71, _x72, _x73) {\n        return _createMint.apply(this, arguments);\n      }\n\n      return createMint;\n    }()\n  }, {\n    key: \"createWrappedNativeAccount\",\n    value: function () {\n      var _createWrappedNativeAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee23(connection, programId, owner, payer, amount) {\n        var balanceNeeded, newAccount, transaction;\n        return _regeneratorRuntime.wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                _context23.next = 2;\n                return Token.getMinBalanceRentForExemptAccount(connection);\n\n              case 2:\n                balanceNeeded = _context23.sent;\n                // Create a new account\n                newAccount = new Account();\n                transaction = new Transaction();\n                transaction.add(SystemProgram.createAccount({\n                  fromPubkey: payer.publicKey,\n                  newAccountPubkey: newAccount.publicKey,\n                  lamports: balanceNeeded,\n                  space: AccountLayout.span,\n                  programId: programId\n                })); // Send lamports to it (these will be wrapped into native tokens by the token program)\n\n                transaction.add(SystemProgram.transfer({\n                  fromPubkey: payer.publicKey,\n                  toPubkey: newAccount.publicKey,\n                  lamports: amount\n                })); // Assign the new account to the native token mint.\n                // the account will be initialized with a balance equal to the native token balance.\n                // (i.e. amount)\n\n                transaction.add(Token.createInitAccountInstruction(programId, NATIVE_MINT, newAccount.publicKey, owner)); // Send the three instructions\n\n                _context23.next = 10;\n                return sendAndConfirmTransaction('createAccount, transfer, and initializeAccount', connection, transaction, payer, newAccount);\n\n              case 10:\n                return _context23.abrupt(\"return\", newAccount.publicKey);\n\n              case 11:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23);\n      }));\n\n      function createWrappedNativeAccount(_x74, _x75, _x76, _x77, _x78) {\n        return _createWrappedNativeAccount.apply(this, arguments);\n      }\n\n      return createWrappedNativeAccount;\n    }()\n  }, {\n    key: \"createInitMintInstruction\",\n    value: function createInitMintInstruction(programId, mint, decimals, mintAuthority, freezeAuthority) {\n      var keys = [{\n        pubkey: mint,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }];\n      var commandDataLayout = struct([u8('instruction'), u8('decimals'), publicKey('mintAuthority'), u8('option'), publicKey('freezeAuthority')]);\n      var data = Buffer.alloc(1024);\n      {\n        var encodeLength = commandDataLayout.encode({\n          instruction: 0,\n          // InitializeMint instruction\n          decimals: decimals,\n          mintAuthority: mintAuthority.toBuffer(),\n          option: freezeAuthority === null ? 0 : 1,\n          freezeAuthority: (freezeAuthority || new PublicKey()).toBuffer()\n        }, data);\n        data = data.slice(0, encodeLength);\n      }\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n    /**\n     * Construct an InitializeAccount instruction\n     *\n     * @param programId SPL Token program account\n     * @param mint Token mint account\n     * @param account New account\n     * @param owner Owner of the new account\n     */\n\n  }, {\n    key: \"createInitAccountInstruction\",\n    value: function createInitAccountInstruction(programId, mint, account, owner) {\n      var keys = [{\n        pubkey: account,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: mint,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: owner,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }];\n      var dataLayout = struct([u8('instruction')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 1 // InitializeAccount instruction\n\n      }, data);\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n    /**\n     * Construct a Transfer instruction\n     *\n     * @param programId SPL Token program account\n     * @param source Source account\n     * @param destination Destination account\n     * @param owner Owner of the source account\n     * @param multiSigners Signing accounts if `authority` is a multiSig\n     * @param amount Number of tokens to transfer\n     */\n\n  }, {\n    key: \"createTransferInstruction\",\n    value: function createTransferInstruction(programId, source, destination, owner, multiSigners, amount) {\n      var dataLayout = struct([u8('instruction'), uint64('amount')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 3,\n        // Transfer instruction\n        amount: new u64(amount).toBuffer()\n      }, data);\n      var keys = [{\n        pubkey: source,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: destination,\n        isSigner: false,\n        isWritable: true\n      }];\n\n      if (multiSigners.length === 0) {\n        keys.push({\n          pubkey: owner,\n          isSigner: true,\n          isWritable: false\n        });\n      } else {\n        keys.push({\n          pubkey: owner,\n          isSigner: false,\n          isWritable: false\n        });\n        multiSigners.forEach(function (signer) {\n          return keys.push({\n            pubkey: signer.publicKey,\n            isSigner: true,\n            isWritable: false\n          });\n        });\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n    /**\n     * Construct an Approve instruction\n     *\n     * @param programId SPL Token program account\n     * @param account Public key of the account\n     * @param delegate Account authorized to perform a transfer of tokens from the source account\n     * @param owner Owner of the source account\n     * @param multiSigners Signing accounts if `owner` is a multiSig\n     * @param amount Maximum number of tokens the delegate may transfer\n     */\n\n  }, {\n    key: \"createApproveInstruction\",\n    value: function createApproveInstruction(programId, account, delegate, owner, multiSigners, amount) {\n      var dataLayout = struct([u8('instruction'), uint64('amount')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 4,\n        // Approve instruction\n        amount: new u64(amount).toBuffer()\n      }, data);\n      var keys = [{\n        pubkey: account,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: delegate,\n        isSigner: false,\n        isWritable: false\n      }];\n\n      if (multiSigners.length === 0) {\n        keys.push({\n          pubkey: owner,\n          isSigner: true,\n          isWritable: false\n        });\n      } else {\n        keys.push({\n          pubkey: owner,\n          isSigner: false,\n          isWritable: false\n        });\n        multiSigners.forEach(function (signer) {\n          return keys.push({\n            pubkey: signer.publicKey,\n            isSigner: true,\n            isWritable: false\n          });\n        });\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n    /**\n     * Construct a Revoke instruction\n     *\n     * @param programId SPL Token program account\n     * @param account Public key of the account\n     * @param owner Owner of the source account\n     * @param multiSigners Signing accounts if `owner` is a multiSig\n     */\n\n  }, {\n    key: \"createRevokeInstruction\",\n    value: function createRevokeInstruction(programId, account, owner, multiSigners) {\n      var dataLayout = struct([u8('instruction')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 5 // Approve instruction\n\n      }, data);\n      var keys = [{\n        pubkey: account,\n        isSigner: false,\n        isWritable: true\n      }];\n\n      if (multiSigners.length === 0) {\n        keys.push({\n          pubkey: owner,\n          isSigner: true,\n          isWritable: false\n        });\n      } else {\n        keys.push({\n          pubkey: owner,\n          isSigner: false,\n          isWritable: false\n        });\n        multiSigners.forEach(function (signer) {\n          return keys.push({\n            pubkey: signer.publicKey,\n            isSigner: true,\n            isWritable: false\n          });\n        });\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n    /**\n     * Construct a SetAuthority instruction\n     *\n     * @param programId SPL Token program account\n     * @param account Public key of the account\n     * @param newAuthority New authority of the account\n     * @param authorityType Type of authority to set\n     * @param currentAuthority Current authority of the specified type\n     * @param multiSigners Signing accounts if `currentAuthority` is a multiSig\n     */\n\n  }, {\n    key: \"createSetAuthorityInstruction\",\n    value: function createSetAuthorityInstruction(programId, account, newAuthority, authorityType, currentAuthority, multiSigners) {\n      var commandDataLayout = struct([u8('instruction'), u8('authorityType'), u8('option'), publicKey('newAuthority')]);\n      var data = Buffer.alloc(1024);\n      {\n        var encodeLength = commandDataLayout.encode({\n          instruction: 6,\n          // SetAuthority instruction\n          authorityType: AuthorityTypeCodes[authorityType],\n          option: newAuthority === null ? 0 : 1,\n          newAuthority: (newAuthority || new PublicKey()).toBuffer()\n        }, data);\n        data = data.slice(0, encodeLength);\n      }\n      var keys = [{\n        pubkey: account,\n        isSigner: false,\n        isWritable: true\n      }];\n\n      if (multiSigners.length === 0) {\n        keys.push({\n          pubkey: currentAuthority,\n          isSigner: true,\n          isWritable: false\n        });\n      } else {\n        keys.push({\n          pubkey: currentAuthority,\n          isSigner: false,\n          isWritable: false\n        });\n        multiSigners.forEach(function (signer) {\n          return keys.push({\n            pubkey: signer.publicKey,\n            isSigner: true,\n            isWritable: false\n          });\n        });\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n    /**\n     * Construct a MintTo instruction\n     *\n     * @param programId SPL Token program account\n     * @param mint Public key of the mint\n     * @param dest Public key of the account to mint to\n     * @param authority The mint authority\n     * @param multiSigners Signing accounts if `authority` is a multiSig\n     * @param amount Amount to mint\n     */\n\n  }, {\n    key: \"createMintToInstruction\",\n    value: function createMintToInstruction(programId, mint, dest, authority, multiSigners, amount) {\n      var dataLayout = struct([u8('instruction'), uint64('amount')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 7,\n        // MintTo instruction\n        amount: new u64(amount).toBuffer()\n      }, data);\n      var keys = [{\n        pubkey: mint,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: dest,\n        isSigner: false,\n        isWritable: true\n      }];\n\n      if (multiSigners.length === 0) {\n        keys.push({\n          pubkey: authority,\n          isSigner: true,\n          isWritable: false\n        });\n      } else {\n        keys.push({\n          pubkey: authority,\n          isSigner: false,\n          isWritable: false\n        });\n        multiSigners.forEach(function (signer) {\n          return keys.push({\n            pubkey: signer.publicKey,\n            isSigner: true,\n            isWritable: false\n          });\n        });\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n    /**\n     * Construct a Burn instruction\n     *\n     * @param programId SPL Token program account\n     * @param mint Mint for the account\n     * @param account Account to burn tokens from\n     * @param owner Owner of the account\n     * @param multiSigners Signing accounts if `authority` is a multiSig\n     * @param amount amount to burn\n     */\n\n  }, {\n    key: \"createBurnInstruction\",\n    value: function createBurnInstruction(programId, mint, account, owner, multiSigners, amount) {\n      var dataLayout = struct([u8('instruction'), uint64('amount')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 8,\n        // Burn instruction\n        amount: new u64(amount).toBuffer()\n      }, data);\n      var keys = [{\n        pubkey: account,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: mint,\n        isSigner: false,\n        isWritable: true\n      }];\n\n      if (multiSigners.length === 0) {\n        keys.push({\n          pubkey: owner,\n          isSigner: true,\n          isWritable: false\n        });\n      } else {\n        keys.push({\n          pubkey: owner,\n          isSigner: false,\n          isWritable: false\n        });\n        multiSigners.forEach(function (signer) {\n          return keys.push({\n            pubkey: signer.publicKey,\n            isSigner: true,\n            isWritable: false\n          });\n        });\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n    /**\n     * Construct a Close instruction\n     *\n     * @param programId SPL Token program account\n     * @param account Account to close\n     * @param dest Account to receive the remaining balance of the closed account\n     * @param authority Account Close authority\n     * @param multiSigners Signing accounts if `owner` is a multiSig\n     */\n\n  }, {\n    key: \"createCloseAccountInstruction\",\n    value: function createCloseAccountInstruction(programId, account, dest, owner, multiSigners) {\n      var dataLayout = struct([u8('instruction')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 9 // CloseAccount instruction\n\n      }, data);\n      var keys = [{\n        pubkey: account,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: dest,\n        isSigner: false,\n        isWritable: true\n      }];\n\n      if (multiSigners.length === 0) {\n        keys.push({\n          pubkey: owner,\n          isSigner: true,\n          isWritable: false\n        });\n      } else {\n        keys.push({\n          pubkey: owner,\n          isSigner: false,\n          isWritable: false\n        });\n        multiSigners.forEach(function (signer) {\n          return keys.push({\n            pubkey: signer.publicKey,\n            isSigner: true,\n            isWritable: false\n          });\n        });\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n    /**\n     * Construct a Freeze instruction\n     *\n     * @param programId SPL Token program account\n     * @param account Account to freeze\n     * @param mint Mint account\n     * @param authority Mint freeze authority\n     * @param multiSigners Signing accounts if `owner` is a multiSig\n     */\n\n  }, {\n    key: \"createFreezeAccountInstruction\",\n    value: function createFreezeAccountInstruction(programId, account, mint, authority, multiSigners) {\n      var dataLayout = struct([u8('instruction')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 10 // FreezeAccount instruction\n\n      }, data);\n      var keys = [{\n        pubkey: account,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: mint,\n        isSigner: false,\n        isWritable: false\n      }];\n\n      if (multiSigners.length === 0) {\n        keys.push({\n          pubkey: authority,\n          isSigner: true,\n          isWritable: false\n        });\n      } else {\n        keys.push({\n          pubkey: authority,\n          isSigner: false,\n          isWritable: false\n        });\n        multiSigners.forEach(function (signer) {\n          return keys.push({\n            pubkey: signer.publicKey,\n            isSigner: true,\n            isWritable: false\n          });\n        });\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n    /**\n     * Construct a Thaw instruction\n     *\n     * @param programId SPL Token program account\n     * @param account Account to thaw\n     * @param mint Mint account\n     * @param authority Mint freeze authority\n     * @param multiSigners Signing accounts if `owner` is a multiSig\n     */\n\n  }, {\n    key: \"createThawAccountInstruction\",\n    value: function createThawAccountInstruction(programId, account, mint, authority, multiSigners) {\n      var dataLayout = struct([u8('instruction')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 11 // ThawAccount instruction\n\n      }, data);\n      var keys = [{\n        pubkey: account,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: mint,\n        isSigner: false,\n        isWritable: false\n      }];\n\n      if (multiSigners.length === 0) {\n        keys.push({\n          pubkey: authority,\n          isSigner: true,\n          isWritable: false\n        });\n      } else {\n        keys.push({\n          pubkey: authority,\n          isSigner: false,\n          isWritable: false\n        });\n        multiSigners.forEach(function (signer) {\n          return keys.push({\n            pubkey: signer.publicKey,\n            isSigner: true,\n            isWritable: false\n          });\n        });\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n    /**\n     * Construct a Transfer2 instruction\n     *\n     * @param programId SPL Token program account\n     * @param source Source account\n     * @param mint Mint account\n     * @param destination Destination account\n     * @param owner Owner of the source account\n     * @param multiSigners Signing accounts if `authority` is a multiSig\n     * @param amount Number of tokens to transfer\n     * @param decimals Number of decimals in transfer amount\n     */\n\n  }, {\n    key: \"createTransfer2Instruction\",\n    value: function createTransfer2Instruction(programId, source, mint, destination, owner, multiSigners, amount, decimals) {\n      var dataLayout = struct([u8('instruction'), uint64('amount'), u8('decimals')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 12,\n        // Transfer2 instruction\n        amount: new u64(amount).toBuffer(),\n        decimals: decimals\n      }, data);\n      var keys = [{\n        pubkey: source,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: mint,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: destination,\n        isSigner: false,\n        isWritable: true\n      }];\n\n      if (multiSigners.length === 0) {\n        keys.push({\n          pubkey: owner,\n          isSigner: true,\n          isWritable: false\n        });\n      } else {\n        keys.push({\n          pubkey: owner,\n          isSigner: false,\n          isWritable: false\n        });\n        multiSigners.forEach(function (signer) {\n          return keys.push({\n            pubkey: signer.publicKey,\n            isSigner: true,\n            isWritable: false\n          });\n        });\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n    /**\n     * Construct an Approve2 instruction\n     *\n     * @param programId SPL Token program account\n     * @param account Public key of the account\n     * @param mint Mint account\n     * @param delegate Account authorized to perform a transfer of tokens from the source account\n     * @param owner Owner of the source account\n     * @param multiSigners Signing accounts if `owner` is a multiSig\n     * @param amount Maximum number of tokens the delegate may transfer\n     * @param decimals Number of decimals in approve amount\n     */\n\n  }, {\n    key: \"createApprove2Instruction\",\n    value: function createApprove2Instruction(programId, account, mint, delegate, owner, multiSigners, amount, decimals) {\n      var dataLayout = struct([u8('instruction'), uint64('amount'), u8('decimals')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 13,\n        // Approve2 instruction\n        amount: new u64(amount).toBuffer(),\n        decimals: decimals\n      }, data);\n      var keys = [{\n        pubkey: account,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: mint,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: delegate,\n        isSigner: false,\n        isWritable: false\n      }];\n\n      if (multiSigners.length === 0) {\n        keys.push({\n          pubkey: owner,\n          isSigner: true,\n          isWritable: false\n        });\n      } else {\n        keys.push({\n          pubkey: owner,\n          isSigner: false,\n          isWritable: false\n        });\n        multiSigners.forEach(function (signer) {\n          return keys.push({\n            pubkey: signer.publicKey,\n            isSigner: true,\n            isWritable: false\n          });\n        });\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n    /**\n     * Construct a MintTo2 instruction\n     *\n     * @param programId SPL Token program account\n     * @param mint Public key of the mint\n     * @param dest Public key of the account to mint to\n     * @param authority The mint authority\n     * @param multiSigners Signing accounts if `authority` is a multiSig\n     * @param amount Amount to mint\n     * @param decimals Number of decimals in amount to mint\n     */\n\n  }, {\n    key: \"createMintTo2Instruction\",\n    value: function createMintTo2Instruction(programId, mint, dest, authority, multiSigners, amount, decimals) {\n      var dataLayout = struct([u8('instruction'), uint64('amount'), u8('decimals')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 14,\n        // MintTo2 instruction\n        amount: new u64(amount).toBuffer(),\n        decimals: decimals\n      }, data);\n      var keys = [{\n        pubkey: mint,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: dest,\n        isSigner: false,\n        isWritable: true\n      }];\n\n      if (multiSigners.length === 0) {\n        keys.push({\n          pubkey: authority,\n          isSigner: true,\n          isWritable: false\n        });\n      } else {\n        keys.push({\n          pubkey: authority,\n          isSigner: false,\n          isWritable: false\n        });\n        multiSigners.forEach(function (signer) {\n          return keys.push({\n            pubkey: signer.publicKey,\n            isSigner: true,\n            isWritable: false\n          });\n        });\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n    /**\n     * Construct a Burn2 instruction\n     *\n     * @param programId SPL Token program account\n     * @param mint Mint for the account\n     * @param account Account to burn tokens from\n     * @param owner Owner of the account\n     * @param multiSigners Signing accounts if `authority` is a multiSig\n     * @param amount amount to burn\n     */\n\n  }, {\n    key: \"createBurn2Instruction\",\n    value: function createBurn2Instruction(programId, mint, account, owner, multiSigners, amount, decimals) {\n      var dataLayout = struct([u8('instruction'), uint64('amount'), u8('decimals')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 15,\n        // Burn2 instruction\n        amount: new u64(amount).toBuffer(),\n        decimals: decimals\n      }, data);\n      var keys = [{\n        pubkey: account,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: mint,\n        isSigner: false,\n        isWritable: true\n      }];\n\n      if (multiSigners.length === 0) {\n        keys.push({\n          pubkey: owner,\n          isSigner: true,\n          isWritable: false\n        });\n      } else {\n        keys.push({\n          pubkey: owner,\n          isSigner: false,\n          isWritable: false\n        });\n        multiSigners.forEach(function (signer) {\n          return keys.push({\n            pubkey: signer.publicKey,\n            isSigner: true,\n            isWritable: false\n          });\n        });\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n  }]);\n\n  return Token;\n}();\n\nexport { AccountLayout, MintLayout, NATIVE_MINT, Token, u64 };","map":null,"metadata":{},"sourceType":"module"}
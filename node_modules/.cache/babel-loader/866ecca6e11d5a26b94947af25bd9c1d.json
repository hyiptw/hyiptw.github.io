{"ast":null,"code":"import _regeneratorRuntime from \"/home/fs/srmswap/oyster-swap/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/fs/srmswap/oyster-swap/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _toConsumableArray from \"/home/fs/srmswap/oyster-swap/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/fs/srmswap/oyster-swap/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/fs/srmswap/oyster-swap/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/home/fs/srmswap/oyster-swap/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/home/fs/srmswap/oyster-swap/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/fs/srmswap/oyster-swap/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/fs/srmswap/oyster-swap/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport assert from 'assert';\nimport BN from 'bn.js';\nimport { blob, struct, u8, nu64 } from 'buffer-layout';\nimport { sendAndConfirmTransaction as sendAndConfirmTransaction$1, TransactionInstruction, Transaction, SystemProgram, PublicKey } from '@solana/web3.js';\n/**\n * Layout for a public key\n */\n\nvar publicKey = function publicKey() {\n  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'publicKey';\n  return blob(32, property);\n};\n/**\n * Layout for a 64bit unsigned value\n */\n\n\nvar uint64 = function uint64() {\n  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'uint64';\n  return blob(8, property);\n};\n\nfunction sendAndConfirmTransaction(title, connection, transaction) {\n  for (var _len = arguments.length, signers = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    signers[_key - 3] = arguments[_key];\n  }\n\n  return sendAndConfirmTransaction$1(connection, transaction, signers, {\n    skipPreflight: false,\n    commitment: 'recent',\n    preflightCommitment: 'recent'\n  });\n}\n/**\n * Some amount of tokens\n */\n\n\nvar Numberu64 = /*#__PURE__*/function (_BN) {\n  _inherits(Numberu64, _BN);\n\n  var _super = _createSuper(Numberu64);\n\n  function Numberu64() {\n    _classCallCheck(this, Numberu64);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Numberu64, [{\n    key: \"toBuffer\",\n\n    /**\n     * Convert to Buffer representation\n     */\n    value: function toBuffer() {\n      var a = _get(_getPrototypeOf(Numberu64.prototype), \"toArray\", this).call(this).reverse();\n\n      var b = Buffer.from(a);\n\n      if (b.length === 8) {\n        return b;\n      }\n\n      assert(b.length < 8, 'Numberu64 too large');\n      var zeroPad = Buffer.alloc(8);\n      b.copy(zeroPad);\n      return zeroPad;\n    }\n    /**\n     * Construct a Numberu64 from Buffer representation\n     */\n\n  }], [{\n    key: \"fromBuffer\",\n    value: function fromBuffer(buffer) {\n      assert(buffer.length === 8, \"Invalid buffer length: \".concat(buffer.length));\n      return new BN(_toConsumableArray(buffer).reverse().map(function (i) {\n        return \"00\".concat(i.toString(16)).slice(-2);\n      }).join(''), 16);\n    }\n  }]);\n\n  return Numberu64;\n}(BN);\n/**\n * Information about a token swap\n */\n\n/**\n * @private\n */\n\n\nvar TokenSwapLayout = struct([u8('isInitialized'), u8('nonce'), publicKey('tokenAccountA'), publicKey('tokenAccountB'), publicKey('tokenPool'), uint64('feesNumerator'), uint64('feesDenominator')]);\n/**\n * An ERC20-like Token\n */\n\nvar TokenSwap = /*#__PURE__*/function () {\n  /**\n   * @private\n   */\n\n  /**\n   * The public key identifying this token\n   */\n\n  /**\n   * Program Identifier for the Token Swap program\n   */\n\n  /**\n   * Fee payer\n   */\n\n  /**\n   * Create a Token object attached to the specific token\n   *\n   * @param connection The connection to use\n   * @param token Public key of the token\n   * @param programId Optional token programId, uses the system programId by default\n   * @param payer Payer of fees\n   */\n  function TokenSwap(connection, tokenSwap, programId, payer) {\n    _classCallCheck(this, TokenSwap);\n\n    _defineProperty(this, \"connection\", void 0);\n\n    _defineProperty(this, \"tokenSwap\", void 0);\n\n    _defineProperty(this, \"programId\", void 0);\n\n    _defineProperty(this, \"payer\", void 0);\n\n    Object.assign(this, {\n      connection: connection,\n      tokenSwap: tokenSwap,\n      programId: programId,\n      payer: payer\n    });\n  }\n  /**\n   * Get the minimum balance for the token swap account to be rent exempt\n   *\n   * @return Number of lamports required\n   */\n\n\n  _createClass(TokenSwap, [{\n    key: \"getInfo\",\n\n    /**\n     * Retrieve tokenSwap information\n     */\n    value: function () {\n      var _getInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var accountInfo, data, tokenSwapInfo;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.connection.getAccountInfo(this.tokenSwap);\n\n              case 2:\n                accountInfo = _context.sent;\n\n                if (!(accountInfo === null)) {\n                  _context.next = 5;\n                  break;\n                }\n\n                throw new Error('Failed to find token swap account');\n\n              case 5:\n                if (accountInfo.owner.equals(this.programId)) {\n                  _context.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Invalid token swap owner: \".concat(JSON.stringify(accountInfo.owner)));\n\n              case 7:\n                data = Buffer.from(accountInfo.data);\n                tokenSwapInfo = TokenSwapLayout.decode(data);\n\n                if (tokenSwapInfo.isInitialized) {\n                  _context.next = 11;\n                  break;\n                }\n\n                throw new Error(\"Invalid token swap state\");\n\n              case 11:\n                // already properly filled in\n                // tokenSwapInfo.nonce = tokenSwapInfo.nonce;\n                tokenSwapInfo.tokenAccountA = new PublicKey(tokenSwapInfo.tokenAccountA);\n                tokenSwapInfo.tokenAccountB = new PublicKey(tokenSwapInfo.tokenAccountB);\n                tokenSwapInfo.tokenPool = new PublicKey(tokenSwapInfo.tokenPool);\n                tokenSwapInfo.feesNumerator = Numberu64.fromBuffer(tokenSwapInfo.feesNumerator);\n                tokenSwapInfo.feesDenominator = Numberu64.fromBuffer(tokenSwapInfo.feesDenominator);\n                tokenSwapInfo.feeRatio = tokenSwapInfo.feesNumerator.toNumber() / tokenSwapInfo.feesDenominator.toNumber();\n                return _context.abrupt(\"return\", tokenSwapInfo);\n\n              case 18:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getInfo() {\n        return _getInfo.apply(this, arguments);\n      }\n\n      return getInfo;\n    }()\n    /**\n     * Swap the tokens in the pool\n     *\n     * @param authority Authority\n     * @param source Source account\n     * @param swapSource Base account to swap into, must be a source token\n     * @param swapDestination Base account to swap from, must be a destination token\n     * @param destination Destination token account\n     * @param tokenProgramId Token program id\n     * @param amount Amount to transfer from source account\n     */\n\n  }, {\n    key: \"swap\",\n    value: function () {\n      var _swap = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(authority, source, swapSource, swapDestination, destination, tokenProgramId, amountIn, minimumAmountOut) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return sendAndConfirmTransaction('swap', this.connection, new Transaction().add(TokenSwap.swapInstruction(this.tokenSwap, authority, source, swapSource, swapDestination, destination, this.programId, tokenProgramId, amountIn, minimumAmountOut)), this.payer);\n\n              case 2:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function swap(_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8) {\n        return _swap.apply(this, arguments);\n      }\n\n      return swap;\n    }()\n  }, {\n    key: \"deposit\",\n\n    /**\n     * Deposit some tokens into the pool\n     *\n     * @param authority Authority\n     * @param sourceA Source account A\n     * @param sourceB Source account B\n     * @param intoA Base account A to deposit into\n     * @param intoB Base account B to deposit into\n     * @param poolToken Pool token\n     * @param poolAccount Pool account to deposit the generated tokens\n     * @param tokenProgramId Token program id\n     * @param amount Amount of pool token to deposit, token A and B amount are set by the exchange rate relative to the total pool token supply\n     */\n    value: function () {\n      var _deposit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(authority, sourceA, sourceB, intoA, intoB, poolToken, poolAccount, tokenProgramId, poolTokenAmount, maximumTokenA, maximumTokenB) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return sendAndConfirmTransaction('deposit', this.connection, new Transaction().add(TokenSwap.depositInstruction(this.tokenSwap, authority, sourceA, sourceB, intoA, intoB, poolToken, poolAccount, this.programId, tokenProgramId, poolTokenAmount, maximumTokenA, maximumTokenB)), this.payer);\n\n              case 2:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function deposit(_x9, _x10, _x11, _x12, _x13, _x14, _x15, _x16, _x17, _x18, _x19) {\n        return _deposit.apply(this, arguments);\n      }\n\n      return deposit;\n    }()\n  }, {\n    key: \"withdraw\",\n\n    /**\n     * Withdraw the token from the pool at the current ratio\n     *\n     * @param authority Authority\n     * @param sourcePoolAccount Source pool account\n     * @param poolToken Pool token\n     * @param fromA Base account A to withdraw from\n     * @param fromB Base account B to withdraw from\n     * @param userAccountA Token A user account\n     * @param userAccountB token B user account\n     * @param tokenProgramId Token program id\n     * @param amount Amount of pool token to withdraw, token A and B amount are set by the exchange rate relative to the total pool token supply\n     */\n    value: function () {\n      var _withdraw = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(authority, poolMint, sourcePoolAccount, fromA, fromB, userAccountA, userAccountB, tokenProgramId, poolTokenAmount, minimumTokenA, minimumTokenB) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return sendAndConfirmTransaction('withdraw', this.connection, new Transaction().add(TokenSwap.withdrawInstruction(this.tokenSwap, authority, poolMint, sourcePoolAccount, fromA, fromB, userAccountA, userAccountB, this.programId, tokenProgramId, poolTokenAmount, minimumTokenA, minimumTokenB)), this.payer);\n\n              case 2:\n                return _context4.abrupt(\"return\", _context4.sent);\n\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function withdraw(_x20, _x21, _x22, _x23, _x24, _x25, _x26, _x27, _x28, _x29, _x30) {\n        return _withdraw.apply(this, arguments);\n      }\n\n      return withdraw;\n    }()\n  }], [{\n    key: \"getMinBalanceRentForExemptTokenSwap\",\n    value: function () {\n      var _getMinBalanceRentForExemptTokenSwap = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(connection) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return connection.getMinimumBalanceForRentExemption(TokenSwapLayout.span);\n\n              case 2:\n                return _context5.abrupt(\"return\", _context5.sent);\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n\n      function getMinBalanceRentForExemptTokenSwap(_x31) {\n        return _getMinBalanceRentForExemptTokenSwap.apply(this, arguments);\n      }\n\n      return getMinBalanceRentForExemptTokenSwap;\n    }()\n  }, {\n    key: \"createInitSwapInstruction\",\n    value: function createInitSwapInstruction(tokenSwapAccount, authority, nonce, tokenAccountA, tokenAccountB, tokenPool, tokenAccountPool, tokenProgramId, swapProgramId, feeNumerator, feeDenominator) {\n      var keys = [{\n        pubkey: tokenSwapAccount.publicKey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: authority,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: tokenAccountA,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: tokenAccountB,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: tokenPool,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: tokenAccountPool,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: tokenProgramId,\n        isSigner: false,\n        isWritable: false\n      }];\n      var commandDataLayout = struct([u8('instruction'), nu64('feeNumerator'), nu64('feeDenominator'), u8('nonce')]);\n      var data = Buffer.alloc(1024);\n      {\n        var encodeLength = commandDataLayout.encode({\n          instruction: 0,\n          // InitializeSwap instruction\n          feeNumerator: feeNumerator,\n          feeDenominator: feeDenominator,\n          nonce: nonce\n        }, data);\n        data = data.slice(0, encodeLength);\n      }\n      return new TransactionInstruction({\n        keys: keys,\n        programId: swapProgramId,\n        data: data\n      });\n    }\n    /**\n     * Create a new Token Swap\n     *\n     * @param connection The connection to use\n     * @param payer Pays for the transaction\n     * @param tokenSwapAccount The token swap account\n     * @param authority The authority over the swap and accounts\n     * @param tokenAccountA: The Swap's Token A account\n     * @param tokenAccountB: The Swap's Token B account\n     * @param tokenPool The pool token\n     * @param tokenAccountPool The pool token account\n     * @param tokenProgramId The program id of the token program\n     * @param feeNumerator Numerator of the fee ratio\n     * @param feeDenominator Denominator of the fee ratio\n     * @param swapProgramId Program ID of the token-swap program\n     * @return Token object for the newly minted token, Public key of the account holding the total supply of new tokens\n     */\n\n  }, {\n    key: \"createTokenSwap\",\n    value: function () {\n      var _createTokenSwap = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(connection, payer, tokenSwapAccount, authority, tokenAccountA, tokenAccountB, tokenPool, tokenAccountPool, tokenProgramId, nonce, feeNumerator, feeDenominator, swapProgramId) {\n        var transaction, tokenSwap, balanceNeeded, instruction;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                tokenSwap = new TokenSwap(connection, tokenSwapAccount.publicKey, swapProgramId, payer); // Allocate memory for the account\n\n                _context6.next = 3;\n                return TokenSwap.getMinBalanceRentForExemptTokenSwap(connection);\n\n              case 3:\n                balanceNeeded = _context6.sent;\n                transaction = new Transaction();\n                transaction.add(SystemProgram.createAccount({\n                  fromPubkey: payer.publicKey,\n                  newAccountPubkey: tokenSwapAccount.publicKey,\n                  lamports: balanceNeeded,\n                  space: TokenSwapLayout.span,\n                  programId: swapProgramId\n                }));\n                instruction = TokenSwap.createInitSwapInstruction(tokenSwapAccount, authority, nonce, tokenAccountA, tokenAccountB, tokenPool, tokenAccountPool, tokenProgramId, swapProgramId, feeNumerator, feeDenominator);\n                transaction.add(instruction);\n                _context6.next = 10;\n                return sendAndConfirmTransaction('createAccount and InitializeSwap', connection, transaction, payer, tokenSwapAccount);\n\n              case 10:\n                return _context6.abrupt(\"return\", tokenSwap);\n\n              case 11:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n\n      function createTokenSwap(_x32, _x33, _x34, _x35, _x36, _x37, _x38, _x39, _x40, _x41, _x42, _x43, _x44) {\n        return _createTokenSwap.apply(this, arguments);\n      }\n\n      return createTokenSwap;\n    }()\n  }, {\n    key: \"swapInstruction\",\n    value: function swapInstruction(tokenSwap, authority, source, swapSource, swapDestination, destination, swapProgramId, tokenProgramId, amountIn, minimumAmountOut) {\n      var dataLayout = struct([u8('instruction'), uint64('amountIn'), uint64('minimumAmountOut')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 1,\n        // Swap instruction\n        amountIn: new Numberu64(amountIn).toBuffer(),\n        minimumAmountOut: new Numberu64(minimumAmountOut).toBuffer()\n      }, data);\n      var keys = [{\n        pubkey: tokenSwap,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: authority,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: source,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: swapSource,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: swapDestination,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: destination,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: tokenProgramId,\n        isSigner: false,\n        isWritable: false\n      }];\n      return new TransactionInstruction({\n        keys: keys,\n        programId: swapProgramId,\n        data: data\n      });\n    }\n  }, {\n    key: \"depositInstruction\",\n    value: function depositInstruction(tokenSwap, authority, sourceA, sourceB, intoA, intoB, poolToken, poolAccount, swapProgramId, tokenProgramId, poolTokenAmount, maximumTokenA, maximumTokenB) {\n      var dataLayout = struct([u8('instruction'), uint64('poolTokenAmount'), uint64('maximumTokenA'), uint64('maximumTokenB')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 2,\n        // Deposit instruction\n        poolTokenAmount: new Numberu64(poolTokenAmount).toBuffer(),\n        maximumTokenA: new Numberu64(maximumTokenA).toBuffer(),\n        maximumTokenB: new Numberu64(maximumTokenB).toBuffer()\n      }, data);\n      var keys = [{\n        pubkey: tokenSwap,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: authority,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: sourceA,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: sourceB,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: intoA,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: intoB,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: poolToken,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: poolAccount,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: tokenProgramId,\n        isSigner: false,\n        isWritable: false\n      }];\n      return new TransactionInstruction({\n        keys: keys,\n        programId: swapProgramId,\n        data: data\n      });\n    }\n  }, {\n    key: \"withdrawInstruction\",\n    value: function withdrawInstruction(tokenSwap, authority, poolMint, sourcePoolAccount, fromA, fromB, userAccountA, userAccountB, swapProgramId, tokenProgramId, poolTokenAmount, minimumTokenA, minimumTokenB) {\n      var dataLayout = struct([u8('instruction'), uint64('poolTokenAmount'), uint64('minimumTokenA'), uint64('minimumTokenB')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 3,\n        // Withdraw instruction\n        poolTokenAmount: new Numberu64(poolTokenAmount).toBuffer(),\n        minimumTokenA: new Numberu64(minimumTokenA).toBuffer(),\n        minimumTokenB: new Numberu64(minimumTokenB).toBuffer()\n      }, data);\n      var keys = [{\n        pubkey: tokenSwap,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: authority,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: poolMint,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: sourcePoolAccount,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: fromA,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: fromB,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: userAccountA,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: userAccountB,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: tokenProgramId,\n        isSigner: false,\n        isWritable: false\n      }];\n      return new TransactionInstruction({\n        keys: keys,\n        programId: swapProgramId,\n        data: data\n      });\n    }\n  }]);\n\n  return TokenSwap;\n}();\n\nexport { Numberu64, TokenSwap, TokenSwapLayout };","map":null,"metadata":{},"sourceType":"module"}